\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{pdfpages}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{float}

\usepackage{mips}
\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}

\title{Trabajo Prático 1} 
\author{\\
  Agustin Alejandro Linari, \textit{Padrón Nro. 81.783}\\
  \textit{agustinlinari@gmail.com}\\
  \and
  Juan Ignacio López Pecora, \textit{Padrón Nro. 84.700}\\
  \textit{jlopezpecora@gmail.com}\\
  \and
  Pablo Daniel Sívori, \textit{Padrón: 84.026}\\
  \textit{sivoridaniel@gmail.com}\\
  \\
  \normalsize{2$^{\circ}$ Cuatrimestre de 2016}                           \\
  \normalsize{66.20 Organizacion de Computadoras}                  \\
  \normalsize{Facultad de Ingenieria, Universidad de Buenos Aires} \\
}

%\newcommand{\ip}[2]{(#1, #2)}
                             % Defines \ip{arg1}{arg2} to mean
                             % (arg1, arg2).

%\newcommand{\ip}[2]{\langle #1 | #2\rangle}
                             % This is an alternative definition of
                             % \ip that is commented out.

\begin{document}             % End of preamble and beginning of text.

\maketitle                   % Produces the title.

\begin{abstract}
En el presente trabajo utilizamos el conjunto de instrucciones MIPS y el concepto de ABI para resolver parte de la lógica del programa realizado en el trabajo práctico 0. 
\end{abstract}

\clearpage

\tableofcontents
\clearpage

\part{Desarrollo}

\section{Introduccion}

El objetivo del presente trabajo práctico es familiarizarse con el código de instrucciones MIPS 32. Para ello implementaremos la lógica de cómputo del fractal con dicho código de instrucciones. 
Finalmente compilaremos el programa en el emulador GXemul para poder obtener el código de instrucciones Mips32.

\section{Build}
El correspondiente informe se puede construir utilizando el make con la etiqueta doc la cual borra y genera el informe en formato pdf.

\section{Diseño e Implementación del Programa}


El código fuente del programa se puede encontrar en el anexo \ref{sec:source}.

\subsection{Stack Frame}
A continuación mostramos los diagrama de stack frame de las funciones implementadas en MIPS32.

\begin{figure}[H]
	\centering
		\includegraphics[scale=0.4]{stack1.png}
	\caption{Stack1}
	\label{fig:stack1}
\end{figure}

\begin{figure}[H]
	\centering
		\includegraphics[scale=0.4]{stack2.png}
	\caption{Stack2}
	\label{fig:stack2}
\end{figure}

\begin{figure}[H]
	\centering
		\includegraphics[scale=0.4]{stack3.png}
	\caption{Stack3}
	\label{fig:stack3}
\end{figure}

\begin{figure}[H]
	\centering
		\includegraphics[scale=0.4]{stack4.png}
	\caption{Stack4}
	\label{fig:stack4}
\end{figure}

\clearpage

\section{Corridas de Programa}
\begin{itemize}
\item Todos los programas fueron compilados con el parámetro -O0 (sin optimizaciones)
\item Todas las mediciones corresponden a la ejecución de los programas utilizando el comando time.
\end{itemize}

\subsection{Observaciones}
\begin{itemize}
\item La implementación de mips en cualquiera de sus variantes se ejecuta en menos tiempo que la implementación C pura, con un speed up aproximado de ⅓
\item A medida que el buffer se agranda, el tiempo de sistema se reduce. Esto se debe a que se producen menos syscalls a write.
\item Podemos plantear la hipótesis razonable de que printf está implementada con un buffer (debido al bajo sys time). Para nuestra implementación MIPS, el tamaño del buffer que obtuvo un tiempo sys del mismo orden que la implementación C fue de 16 KB.
\item Contrario a lo que nuestra intuición indicaba, aumentar el buffer para valores mayores a 64 bytes no necesariamente significó (en promedio) en un aumento de performance. Esto puede estar relacionado con la arquitectura del cache emulado, el tamaño de bloque  y su política de reemplazo.
\end{itemize}

\clearpage
\subsection{Conclusión}


Con la realización de este trabajo hemos podido apreciar la diferencia de performance entre dos implementaciones de distinta naturaleza de un mismo algoritmo, implementado en C y en assembly MIPS32.


A la hora de programar, es común que se codifique utilizando lenguajes de alto nivel. El lenguaje de programación C es un lenguaje de propósito general clásico cuyo diseño provee construcciones que mapean de manera eficiente instrucciones de máquina típicas. Las ventajas de utilizar un lenguaje de alto nivel como C son portabilidad (a nivel código fuente) entre diferentes arquitecturas donde se haya implementado el compilador, aumento de productividad - dado que se abstrae de cuestiones de bajo nivel íntimamente ligadas con la arquitectura de la máquina - y reducción en el costo de mantenimiento. Sin embargo, estas ventajas traen aparejado un costo en la performance del programa.


En algunos casos, los requerimientos funcionales de un programa requieren de una performance que puede ser difícil de alcanzar para una implementación en un lenguaje de alto nivel. Mediante un análisis cuantitativo, se determina qué segmentos de código consumen la mayor cantidad de recursos de una computadora -ciclos de CPU, memoria, etc-. Para el caso particular de este trabajo, la función de cómputo del fractal es central en el desempeño de la aplicación.


Aprovechando la posibilidad que brinda el lenguaje C de poder linkear con código assembly, pudimos implementar las funciones clave a medida de la computadora, esto es, codificar utilizando el conjunto de instrucciones de la arquitectura MIPS32, dando como resultado un desempeño superior reflejado en el cálculo del Speed Up.


Podemos concluir que ante requerimientos que condicionen el uso de recursos de una computadora, o la necesidad de proveer una aplicación donde la velocidad de ejecución sea un requerimiento clave, podemos obtener lo mejor de dos mundos, implementando la aplicación en un lenguaje de alto nivel y optimizando los segmentos de código clave implementando en assembly para la arquitectura sobre la cual se ejecutará la aplicación.


Finalmente, vale la pena observar que en un contexto diferente, si dejamos de forzar al compilador C (GCC) a no optimizar el código, se puede dar el caso que el código C compilado, libre de restricciones de optimización, pueda superar el rendimiento de una implementación MIPS hecha por nosotros, debido a la madurez alcanzada de los compiladores modernos y nuestra inexperiencia en la implementación de código assembler.


\clearpage

\part{Apendice}
\appendix


\section{Codigo fuente}\label{sec:source}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\lstset{%
  title=\lstname,
  language=C,
  basicstyle=\footnotesize,
  showspaces=false,
  showstringspaces=false,
  breaklines=true,
  commentstyle=\color{gray},
  numbers=left,
  numberstyle=\tiny\color{gray},
  numbersep=5pt,
  frame=single
}

%\lstinputlisting{../src/complex.h}
%\lstinputlisting{../src/complex.c}
%\lstinputlisting{../src/app.c}

\clearpage

\lstset{%
  language=[mips]Assembler,       % the language of the code
  basicstyle=\footnotesize,       % the size of the fonts that are used for the code
  numbers=left,                   % where to put the line-numbers
  numberstyle=\tiny\color{gray},  % the style that is used for the line-numbers
  stepnumber=1,                   % the step between two line-numbers. If it's 1, each line 
                                  % will be numbered
  numbersep=5pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
  showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  showtabs=false,                 % show tabs within strings adding particular underscores
  frame=single,                   % adds a frame around the code
  rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
  tabsize=4,                      % sets default tabsize to 2 spaces
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
  title=\lstname,                 % show the filename of files included with \lstinputlisting;
                                  % also try caption instead of title
  keywordstyle=\color{blue},      % keyword style
  commentstyle=\color{green},     % comment style
  stringstyle=\color{red},      % string literal style
  escapeinside={\%*}{*)},         % if you want to add a comment within your code
  morekeywords={*}                % if you want to add more keywords to the set
}

%\lstinputlisting{../MIPS32/complex.s}
%\lstinputlisting{../MIPS32/app.s}

\clearpage

\section{Enunciado original}\label{sec:enunciado}
\includepdf[pages={-}]{tp1-2016-2q.pdf}

\end{document}               % End of document.
